<Title:>
    Derby Party - Learn

<index:>
    <div class="bs-docs-header" id="content">
        <div class="container">
            <h1>Resources</h1>
            <p></p>
        </div>
    </div>

    <div class="container">

        <div class="row">
            <div class="col-md-3 sidebar">
                <div class="bs-docs-sidebar hidden-print" role="complementary">
                    <ul class="nav bs-docs-sidenav">
                        <li>
                            <a href="#environment-">Environment</a>
                            <ul class="nav">
                                <li><a href="#debian-">Debian</a></li>
                                <li><a href="#mac-os-">Mac OS</a></li>
                                <li><a href="#windows-">Windows</a></li>
                            </ul>
                        </li>
                        <li><a href="#tool-">Tool</a></li>
                        <li><a href="#structure-">Structure</a></li>
                        <li><a href="#first-request-">First Request</a></li>
                        <li><a href="#data-binding-">Data Binding</a></li>
                        <li><a href="#model-api-">Model Api</a></li>
                        <li><a href="#getting-started-">Getting started</a></li>
                        <li><a href="#create-an-app-">Create an app</a></li>
                        <li><a href="#deploy-to-heroku-">Deploy to Heroku</a></li>
                        <li><a href="#using-existing-data-">Using existing data</a></li>
                    </ul>
                    <a class="back-to-top" href="#top">
                        Back to top
                    </a>
                </div>
            </div>
            <div class="col-md-9 main">
                <h2 id="environment">Environment</h2>
                <p>For Derby you need: <a href="http://nodejs.org">Node</a> (&gt;=0.10), <a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://redis.io/">Redis</a> (&gt;=2.6).<br>If you have all these things, skip this section.</p>
                <h3 id="debian">Debian</h3>
                <p>Same for all Debian family: Debian, Ubuntu, Mint, etc.<br>For Node and Redis we will use the chris-lea repository, Mongo has an official repo.</p>
<pre><code class="lang-bash"><span class="hljs-comment"># Add the repository</span><br><span class="hljs-comment"># node.js</span><br><span class="hljs-built_in">sudo</span> add-apt-repository -y ppa:chris-lea/node.js<br><span class="hljs-comment"># redis</span><br><span class="hljs-built_in">sudo</span> add-apt-repository -y ppa:chris-lea/redis-server<br><span class="hljs-comment"># mongodb</span><br><span class="hljs-built_in">sudo</span> apt-key adv --keyserver hkp://keyserver.ubuntu.com:<span class="hljs-number">80</span> --recv <span class="hljs-number">7</span>F0CEB10<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen'</span> | <span class="hljs-built_in">sudo</span> tee /etc/apt/sources.list.d/<span class="hljs-number">10</span>gen.list<br><br><span class="hljs-comment"># Update the apt-get</span><br><span class="hljs-built_in">sudo</span> apt-get -y update<br><br><span class="hljs-comment"># Set</span><br><span class="hljs-built_in">sudo</span> apt-get -y install nodejs<br><span class="hljs-built_in">sudo</span> apt-get -y install mongodb-<span class="hljs-number">10</span>gen<br><span class="hljs-built_in">sudo</span> apt-get -y install redis-server
</code></pre>
                <h3 id="mac-os">Mac OS</h3>
                <p>As soon as I buy mac</p>
                <h3 id="windows">Windows</h3>
                <p>you should compile redis by yourself</p>
                <h2 id="tool">Tool</h2>
                <p>We certainly can create application from scratch now.<br>But Derby has tool that generates for us the application layout and saves time. Why do not we use it?<br>First we need to install derby npm package globally:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">sudo</span> npm install -g derby
</code></pre>
                <p>Let`s create an application called hello-derby (this is also the name of the folder):</p>
<pre><code class="lang-bash">derby bare hello-derby
</code></pre>
                <p>Tool creates the application and installs all dependencies. It will take some time and in the end you will see:</p>
<pre><code class="lang-bash">  Project created!<br><br>  Try it out:<br>    $ Cd hello-derby<br>    $ Npm start<br><br>  More info at: http://derbyjs.com/
</code></pre>
                <p>Bare - means only layout. You can generate simple list-editing app:</p>
<pre><code class="lang-bash">derby new my-list-edit-app
</code></pre>
                <p>We will examine Javascript application, but if you want Coffeescript, use - coffee,-c:</p>
<pre><code class="lang-bash">derby new -coffee my-cool-coffee-derby-app
</code></pre>
                <p>Or create an application, but does not install dependencies using - noinstall,-n:</p>
<pre><code class="lang-bash">derby new -n empty-node_modules-app
</code></pre>
                <p>More options:</p>
<pre><code class="lang-bash">derby --help
</code></pre>
                <h2 id="structure">Structure</h2>
                <p>This is <code>derby new project</code> structure:</p>
                <p><code>/lib</code> - here is almost all js. If you are on the coffee, it will be a folder /src.<br><code>/lib/app</code> - this is a client application called &#39;app&#39;. Here maybe some of them. It runs on client and server.<br><code>/lib/app/index.js</code> - here app itself is created, and two component libraries are added: &#39;derby-ui-boot&#39; (bootstrap for derby) and &#39;ui&#39; (some components in our Derby app). Then there are routes that will be executed on the server and on the client. At the end controller functions are created - functions that are executed only on the client and are associated with the manipulation of dom.<br><code>/lib/server</code> - server application. Can be only one. Code runs only on server and is not directly accessible form client.<br><code>/lib/server/error.js</code> - here we generate some custom static (only html and css, without the client application) error pages.<br><code>/lib/server/index.js</code> - this creates Express application, configures databases, creates store, adds Connect modules to Express app, some of which are parts of Derby application. At the end it creates a server-side Express route, which generates an error for requests that were not catched by client app router or server (Express) router.<br><code>/node_modules</code> - npm packages.<br><code>/styles</code> - styles are here. Default engine is Stylus (Less and css are supported also).<br><code>/styles/app</code> - styles that will be uploaded to client with client application named &#39;app&#39;.<br><code>/styles/ui</code> - styles for ui component library.<br><code>/ui</code> - component library. Each component consists of js and html files.<br><code>/ui/connectionAlert</code> - an example of a component. If the client went offline, this component displays the label and button «Reconnect». If reconnect failed, it offers to restart the application «Reload».<br><code>/ui/index.js</code> - ui component library settings.<br><code>/views</code> - html templates.<br><code>/views/app</code> - templates that are loaded into client app.<br><code>/views/app/home.html</code> - home page.<br><code>/views/app/index.html</code> - layout for home.html and list.html.<br><code>/views/app/list.html</code> - list page.<br><code>/views/error</code> - templates for the static error pages for /lib/server/error.js<br><code>.npmignore</code> - you will need it if you publish your application as a package to npm.<br><code>Procfile</code> - this is for Heroku.<br><code>README.md</code> - read me<br><code>package.json</code> - setting for npm: which modules download on npm install, what to do on npm start, etc.<br><code>server.js</code> - main file. The entry point of your application. Derby starts Express application here.</p>
                <h2 id="first-request">First Request</h2>
                <p>Now let`s return to hello-derby and start it:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">cd</span> hello-derby<br>npm start
</code></pre>
                <p>See:</p>
<pre><code class="lang-bash"><span class="hljs-number">1234</span> listening. Go to: http://localhost:<span class="hljs-number">3000</span>/
</code></pre>
                <p>Now in your browser go here: <a href="http://localhost:3000/">http://localhost:3000/</a><br>Can you see a label &#39;Bare&#39;?<br>What just happened? Your request reached server, where it was processed by all Connect middleware from <code>/lib/server/index.js</code>, until:</p>
<pre><code class="lang-javascript">.use(app.router())
</code></pre>
                <p>Which is Derby client app router from <code>app/lib/app/index.js</code>:</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page)</span> {</span><br>  page.render();<br>});
</code></pre>
                <p>Here for the path &#39;/&#39; we generate html from template <code>/views/app/index.html</code>. Why index.html? This is by default. Nothing will change if we change to:</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page)</span> {</span><br>  page.render(<span class="hljs-string">'index'</span>);<br>});
</code></pre>
                <p>In <code>index.html</code> we have only section: Body. Also can be: Head, Header, Footer, Scripts, Title, etc. Derby template engine generating html, will find Body section and will put it`s value in the appropriate place, and instead of the other sections (since they are not set), it will put an empty or default values​​. As a result, next html will be returned back to the client:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">!</span> <span class="hljs-attribute">DOCTYPE</span> <span class="hljs-attribute">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"utf-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">style</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"$_css"</span>&gt;</span><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-title">!-$_page-</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span><br>    Bare<br>    <span class="hljs-tag">&lt;<span class="hljs-title">!-$_page-</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">defer</span>=<span class="hljs-value">""</span> <span class="hljs-attribute">async</span>=<span class="hljs-value">""</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"/derby/lib-app-index.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
                <p>What can we see ? Title is empty. No styles. Head - also almost empty. As we might expect. And there is something in the body.<br>All styles from <code>/styles</code> folder will be combined, compressed and showed inline. You can put links to css files to Head section (for example) if you want connect style files.<br>Script <code>/derby/lib-app-index.js</code> - is our client application. As soon as it will be loaded to client it will take everything in it&#39;s hands. So if you change url, client app router will catch it in browser and Derby template engine will generate html also in browser.<br><code>&lt;!-$_page-&gt;</code> and <code>&lt;!-$_page-&gt;</code> - Derby uses html comments like this as internal tags for dynamic binding between data and html. If data changes, only part of html will be regenerated, not entire page. In this case, when router triggered, only Body section will be updated, because we have not set any other section and they all same for all pages.</p>
                <p>You can change text in the templates (and styles) and see the changes instantly in your browser. It has no relation to any dynamic data synchronization. This is for the development convenience. If you change the html and css, it will be automatically compiled, uploaded to the client and replaced the old one. If you change js, application restarts.</p>
                <h2 id="data-binding">Data Binding</h2>
                <p>Let&#39;s separate view from data. For this purpose, there are two ways in Derby. Let&#39;s start with Context. This is object, which we can be added as next (after template name) argument in page.render() and the data from which we can display in html.</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page)</span> {</span><br>  page.render({text: <span class="hljs-string">'text from Context'</span>});<br>});
</code></pre>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">Body:</span>&gt;</span><br>  &#123;text&#125;&#125;
</code></pre>
                <p>Double <code>{</code> template brackets mean that html is not dynamically binded to data. Derby template engine does not track html or data changes. It`s not necessary for Context, because Context - just js-object and does not change, therefore usually use-case for Context is static pages. For dynamic app use Model.</p>
                <p>Model is data manipulation api-object. Also it stores some state inside itself.<br>Where to get the Model? There are many ways (depending on whether you are on the client or on the server), but in the router it goes the second argument (after page) and it is very convenient for us in this situation :</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  page.render();<br>});
</code></pre>
                <p>Let&#39;s put data into Model:</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  model.set(<span class="hljs-string">'_page.text'</span>, <span class="hljs-string">'text in model'</span>);<br>  page.render();<br>});
</code></pre>
                <p><code>_page.text</code> - this is path in the model, where our text will be stored. Path corresponds to json. In this case :</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = model.get(<span class="hljs-string">'_page'</span>);<br><span class="hljs-comment">// obj === {text: 'text in model'}</span>
</code></pre>
                <p>Underscore means that this path is local. That is, it exists only in this Model. And is not synchronized with the database and other Models (other clients). You can create any local path, but <code>_page</code> object is a little bit special. It cleans every time router is triggered, so it is convenient to store data associated with the page in the <code>_page</code> path.<br>In order to see the data from the model, change the template:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">Body:</span>&gt;</span><br>  &#123;_page.text&#125;&#125;
</code></pre>
                <p>Let&#39;s try to make dynamic binding between data and html:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">Body:</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{_page.text}</span> /&gt;</span><br>  {_page.text}
</code></pre>
                <p>Single brackets <code>{</code> mean that the data in the Model is dynamically binded to html. If you change the value in the input, it will change the value in the Model, which in turn changes the text next to the input. That&#39;s an example of two-side dynamic binding between data and html.</p>
                <p>Well, there was not anything complex? 3 lines of code? It`s not serious?<br>Let&#39;s make a really serious thing! Now we will create a web application, whose clients are synchronized with each other. We change the html on one client, this dynamically changes the data on the client, then the data flyes to the server, where conflict resolution algorithm merges data to database and send it to all clients that are subscribed to it, finally on each client data will be converted into html. Suitable? How long does it take to write this using your favorite (before Derby) framework? How many lines of code?</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  model.subscribe(<span class="hljs-string">'page.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-keyword">if</span> (!model.get(<span class="hljs-string">'page.text'</span>)) {<br>      model.set(<span class="hljs-string">'page.text'</span>, <span class="hljs-string">'text in model'</span>);<br>    }<br>    page.render();<br>  });<br>});
</code></pre>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">Body:</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{page.text}</span> /&gt;</span><br>  {page.text}
</code></pre>
                <p>That&#39;s it? o_O Well, in general, yes. Open <a href="http://localhost:3000/">http://localhost:3000/</a> in several browser windows and play with it for a while.</p>
                <p><code>page.text</code> - this is remote path. Unlike the local path, it points to the database. In this case, we created <code>page</code> collection and object with id <code>text</code>. In real life remote paths look like: <code>users.8ddd02f1-b82d-4a9c-9253-fe5b3b86ef41.name</code>, <code>customers.8ddd02f1-b82d-4a9c-9253-fe5b3b86ef41.properties.isLead</code>, <code>products.8ddd02f1-b82d-4a9c-9253-fe5b3b86ef41.prices.1.value</code>.<br><code>model.subscribe</code> - this is way we subscribe client for path <code>page.text</code>. If any other client will change data in the path <code>page.text</code>, server send us new version of data.</p>
                <h2 id="model-api">Model Api</h2>
                <p>Change <code>/lib/app/index.js</code> to:</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  model.subscribe(<span class="hljs-string">'todos'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-keyword">if</span> (!model.get(<span class="hljs-string">'todos'</span>)) {<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 1'</span> });<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 2'</span> });<br>    }<br>    page.render();<br>  });<br>});
</code></pre>
                <p>We just subscribed to whole <code>todos</code> collection. In the future, all of our data manipulation we be done only after we subscribe Model to some data, because before it Model is empty. Then we added a couple of documents to collection if collection is not exist.<br><code>model.add</code> - is a wrapper over <code>model.set</code>. The only thing that it does is generate the id itself. We could write:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> id = model.id(); <span class="hljs-comment">// this way guid is generated by using require('node-uuid').v4()</span><br>model.set(<span class="hljs-string">'todos.'</span> + id, {id: id, text: <span class="hljs-string">'Todo 1'</span> });
</code></pre>
                <p>Our collection stored in Model as js-object. If you will do <code>model.get(&#39;todos&#39;)</code>, you get:</p>
<pre><code class="lang-javascript">{<br>  <span class="hljs-string">"e1b8075c-de9a-458a-aa3c-e9b383691521"</span>:<br>    {<br>      <span class="hljs-string">"text"</span>: <span class="hljs-string">"Todo 1"</span>,<br>      <span class="hljs-string">"id"</span>: <span class="hljs-string">"e1b8075c-de9a-458a-aa3c-e9b383691521"</span><br>    },<br>  <span class="hljs-string">"26cd5f4a-c503-4c25-aeeb-a28c8c034d08"</span>:<br>    {<br>      <span class="hljs-string">"text"</span>: <span class="hljs-string">"Todo 2"</span>,<br>      <span class="hljs-string">"id"</span>: <span class="hljs-string">"26cd5f4a-c503-4c25-aeeb-a28c8c034d08"</span><br>    }<br>}
</code></pre>
                <p>This format (js-object, hash) is good if we want to get documents by id:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todo = model.get(<span class="hljs-string">'todos.e1b8075c-de9a-458a-aa3c-e9b383691521'</span>);
</code></pre>
                <p>But if we want to show list of todos, it`s better to have an array. We can use Filter for this:</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  model.subscribe(<span class="hljs-string">'todos'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-keyword">if</span> (!model.get(<span class="hljs-string">'todos'</span>)) {<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 1'</span> });<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 2'</span> });<br>    }<br><br>    <span class="hljs-keyword">var</span> filter = model.filter(<span class="hljs-string">'todos'</span>);<br>    filter.ref(<span class="hljs-string">'_page.todos'</span>);<br><br>    page.render();<br>  });<br>});
</code></pre>
                <p><code>/views/app/index.html</code></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">Body:</span>&gt;</span><br>  {#each _page.todos as :todo}<br>    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{:todo.text}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span><br>  {/}
</code></pre>
                <p>Here we create a Filter for <code>todos</code>. It monitors changes to the collection and puts result as array into path <code>_page.todos</code> using refList, which will be covered later. But the Filter would not be a Filter , if it not be able to filter. We can do like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todosFilteredArray = model.filter(<span class="hljs-string">'todos'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(todo)</span> {</span><br>    <span class="hljs-keyword">return</span> todo.text === <span class="hljs-string">'Todo 1'</span>;<br>}).get();
</code></pre>
                <p>Here we have filtered array immediately. Same as Filter, there is Sort. You can use them separately or together:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todosSortedArray = model.filter(<span class="hljs-string">'todos'</span>).sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> {</span><br>  <span class="hljs-keyword">return</span> a.text - b.text;<br>}).get();
</code></pre>
                <p>Here we have array sorted by <code>text</code> field.<br>Neither Filter, nor Sort knows nothing about your database. They operate only on data that is in the Model.Fill out Model before use them!</p>
                <p>What`s with refList? This is references. It allows you to bind data between two paths. Using them directly needed in rarely cases, but they are used internally by Filter and Queries.</p>
<pre><code class="lang-javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  model.subscribe(<span class="hljs-string">'todos'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-keyword">if</span> (!model.get(<span class="hljs-string">'todos'</span>)) {<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 1'</span> });<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 2'</span> });<br>    }<br><br>    <span class="hljs-keyword">var</span> ids = <span class="hljs-built_in">Object</span>.keys(model.get(<span class="hljs-string">'todos'</span>));<br>    model.set(<span class="hljs-string">'_page.ids'</span>, ids)<br>    model.refList(<span class="hljs-string">'_page.todos'</span>, <span class="hljs-string">'todos'</span>, <span class="hljs-string">'_page.ids'</span>);<br><br>    page.render();<br>  });<br>});
</code></pre>
                <p><code>ids</code> - a list of ids of those todos, we want to have in result. They also set the order of the array in <code>_page.todos</code>. We can change <code>_page.ids</code> and it is immediately reflected on the <code>_page.todos</code>.</p>
                <p>Let play with subscribe:</p>
<pre><code class="lang-javascript">model.subscribe(<span class="hljs-string">'todos'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-comment">// Subscribe to the entire collection of todos</span><br>});<br>model.subscribe(<span class="hljs-string">'todos.e1b8075c-de9a-458a-aa3c-e9b383691521'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-comment">// Subscribe to one document</span><br>});<br>model.subscribe(<span class="hljs-string">'todos.e1b8075c-de9a-458a-aa3c-e9b383691521.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-comment">// Subscribed to one field of one document</span><br>});<br>model.subscribe(<span class="hljs-string">'users'</span>, <span class="hljs-string">'todos.e1b8075c-de9a-458a-aa3c-e9b383691521.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-comment">// You can combine to not produce extra callbacks</span><br>});
</code></pre>
                <p>Lets suppose we are very busy people and we have a million todos. And we want to subscribe to only those whose text contains certain characters. Why do we need to upload entire collection to the client? Paths and Filter will not help us in this sutiation. It`s time for Queries:</p>
<pre><code class="lang-javascript">app.get (<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(page, model)</span> {</span><br>  <span class="hljs-keyword">var</span> query = model.query(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 1'</span>});<br>  model.subscribe(query, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span><br>    <span class="hljs-keyword">if</span> (!model.get(<span class="hljs-string">'todos'</span>)) {<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 1'</span> });<br>      model.add(<span class="hljs-string">'todos'</span>, {text: <span class="hljs-string">'Todo 2'</span> });<br>    }<br><br>    query.ref(<span class="hljs-string">'_page.todos'</span>);<br><br>    page.render();<br>  });<br>});
</code></pre>
                <p>Here we create Query, subscribe Model to it and puts results as array to <code>_page.todos</code>.<br><code>{text: &#39;Todo 1&#39;}</code> - is Mongo Queries. livedb-mongo adapter transfers this object directly to Mongo. For other databases, you can write your own adapters and make it different way.</p>
                <h2 id="getting-started">Getting started</h2>
                <p>As with all Node.js modules, first install <a href="http://nodejs.org/#download">Node</a>.<br>The Node installer will also install <a href="http://npmjs.org/">npm</a>.</p>
                <p>Install Derby with:</p>
<pre><code><span class="hljs-variable">$ </span>npm install -g derby
</code></pre><p>You will also need to install and start <a href="http://redis.io/download">Redis 2.6</a><br>and <a href="http://www.mongodb.org/downloads">MongoDB</a>.</p>
                <h2 id="create-an-app">Create an app</h2>
                <p>Derby includes a simple project generator:</p>
<pre><code><span class="hljs-variable">$ </span>cd ~<br><span class="hljs-variable">$ </span>derby new first-project<br><span class="hljs-variable">$ </span>cd first-project
</code></pre><p>or, for <a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a>:</p>
<pre><code><span class="hljs-variable">$ </span>cd ~<br><span class="hljs-variable">$ </span>derby new --coffee first-project<br><span class="hljs-variable">$ </span>cd first-project
</code></pre><p>Then, simply fire up your app:</p>
<pre><code><span class="hljs-variable">$ </span>npm start
</code></pre><h2 id="deploy-to-heroku">Deploy to Heroku</h2>
                <p>The default Derby app is already configured for easy deployment to Heroku.<br>First things first, <a href="https://id.heroku.com/signup">signup for Heroku</a> and<br>install <a href="https://toolbelt.heroku.com/">Heroku Toolbelt</a> if you haven&#39;t already.</p>
                <p>The first time you use Heroku, run:</p>
<pre><code><span class="hljs-variable">$ </span>heroku login
</code></pre><p>If not done in the login step, you may also need to upload a public key with:</p>
<pre><code>$ heroku <span class="hljs-built_in">keys</span>:<span class="hljs-built_in">add</span>
</code></pre><p>Form then on, all you have to do to get a new Derby project deployed to Heroku<br>is initialize it as a Git repo,</p>
<pre><code><span class="hljs-variable">$ </span>git init<br><span class="hljs-variable">$ </span>git add .<br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">"init"</span>
</code></pre><p>create a Heroku app with access to Redis and MongoDB,</p>
<pre><code><span class="hljs-variable">$ </span>heroku create<br><span class="hljs-variable">$ </span>heroku <span class="hljs-symbol">addons:</span>add <span class="hljs-symbol">rediscloud:</span><span class="hljs-number">20</span><br><span class="hljs-variable">$ </span>heroku <span class="hljs-symbol">addons:</span>add <span class="hljs-symbol">mongohq:</span>sandbox<br><span class="hljs-variable">$ </span>heroku <span class="hljs-symbol">config:</span>set <span class="hljs-constant">NODE_ENV</span>=production
</code></pre><p>and push!</p>
<pre><code><span class="hljs-variable">$ </span>git push heroku master<br><span class="hljs-variable">$ </span>heroku open
</code></pre><p>Note that while Derby supports multiple servers, it currently requires that<br>clients repeatedly connect to the same server. Heroku does not support sticky<br>sessions or WebSockets, so it isn&#39;t possible to use more than one dyno. You&#39;ll<br>have to use a different hosting option to scale your app.</p>
                <p>For more info, see Heroku&#39;s <a href="https://devcenter.heroku.com/articles/quickstart">Getting Started</a> and <a href="https://devcenter.heroku.com/articles/nodejs">Node.js</a> guides.</p>
                <h2 id="using-existing-data">Using existing data</h2>
                <p>To make getting started with existing data a bit easier, we&#39;ve written a <a href="https://github.com/share/igor">script to initialize the journal</a> in Redis based on a MongoDB database. There is also a <a href="https://github.com/share/godbox">tool to inspect your data</a> once it is initialized. For more info on using these tools, check out <a href="https://www.youtube.com/watch?v=FoOfNCJkAAA">this video</a>.</p>

            </div>

        </div>
    </div>